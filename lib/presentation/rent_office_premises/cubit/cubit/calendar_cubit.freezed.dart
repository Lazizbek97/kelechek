// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'calendar_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CalendarBuildable {
  bool get loading => throw _privateConstructorUsedError;
  bool get success => throw _privateConstructorUsedError;
  bool get failure => throw _privateConstructorUsedError;
  String get selectedDate => throw _privateConstructorUsedError;
  String get dateCount => throw _privateConstructorUsedError;
  String get range => throw _privateConstructorUsedError;
  String get rangeCount => throw _privateConstructorUsedError;
  DateTime? get startDate => throw _privateConstructorUsedError;
  DateTime? get endDate => throw _privateConstructorUsedError;
  DateTime? get focusDate => throw _privateConstructorUsedError;
  List<DateTime?> get dates => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CalendarBuildableCopyWith<CalendarBuildable> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalendarBuildableCopyWith<$Res> {
  factory $CalendarBuildableCopyWith(
          CalendarBuildable value, $Res Function(CalendarBuildable) then) =
      _$CalendarBuildableCopyWithImpl<$Res, CalendarBuildable>;
  @useResult
  $Res call(
      {bool loading,
      bool success,
      bool failure,
      String selectedDate,
      String dateCount,
      String range,
      String rangeCount,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? focusDate,
      List<DateTime?> dates});
}

/// @nodoc
class _$CalendarBuildableCopyWithImpl<$Res, $Val extends CalendarBuildable>
    implements $CalendarBuildableCopyWith<$Res> {
  _$CalendarBuildableCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? success = null,
    Object? failure = null,
    Object? selectedDate = null,
    Object? dateCount = null,
    Object? range = null,
    Object? rangeCount = null,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? focusDate = freezed,
    Object? dates = null,
  }) {
    return _then(_value.copyWith(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      failure: null == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as bool,
      selectedDate: null == selectedDate
          ? _value.selectedDate
          : selectedDate // ignore: cast_nullable_to_non_nullable
              as String,
      dateCount: null == dateCount
          ? _value.dateCount
          : dateCount // ignore: cast_nullable_to_non_nullable
              as String,
      range: null == range
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as String,
      rangeCount: null == rangeCount
          ? _value.rangeCount
          : rangeCount // ignore: cast_nullable_to_non_nullable
              as String,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _value.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      focusDate: freezed == focusDate
          ? _value.focusDate
          : focusDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dates: null == dates
          ? _value.dates
          : dates // ignore: cast_nullable_to_non_nullable
              as List<DateTime?>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CalendarBuildableImplCopyWith<$Res>
    implements $CalendarBuildableCopyWith<$Res> {
  factory _$$CalendarBuildableImplCopyWith(_$CalendarBuildableImpl value,
          $Res Function(_$CalendarBuildableImpl) then) =
      __$$CalendarBuildableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool loading,
      bool success,
      bool failure,
      String selectedDate,
      String dateCount,
      String range,
      String rangeCount,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? focusDate,
      List<DateTime?> dates});
}

/// @nodoc
class __$$CalendarBuildableImplCopyWithImpl<$Res>
    extends _$CalendarBuildableCopyWithImpl<$Res, _$CalendarBuildableImpl>
    implements _$$CalendarBuildableImplCopyWith<$Res> {
  __$$CalendarBuildableImplCopyWithImpl(_$CalendarBuildableImpl _value,
      $Res Function(_$CalendarBuildableImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loading = null,
    Object? success = null,
    Object? failure = null,
    Object? selectedDate = null,
    Object? dateCount = null,
    Object? range = null,
    Object? rangeCount = null,
    Object? startDate = freezed,
    Object? endDate = freezed,
    Object? focusDate = freezed,
    Object? dates = null,
  }) {
    return _then(_$CalendarBuildableImpl(
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      success: null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as bool,
      failure: null == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as bool,
      selectedDate: null == selectedDate
          ? _value.selectedDate
          : selectedDate // ignore: cast_nullable_to_non_nullable
              as String,
      dateCount: null == dateCount
          ? _value.dateCount
          : dateCount // ignore: cast_nullable_to_non_nullable
              as String,
      range: null == range
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as String,
      rangeCount: null == rangeCount
          ? _value.rangeCount
          : rangeCount // ignore: cast_nullable_to_non_nullable
              as String,
      startDate: freezed == startDate
          ? _value.startDate
          : startDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endDate: freezed == endDate
          ? _value.endDate
          : endDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      focusDate: freezed == focusDate
          ? _value.focusDate
          : focusDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      dates: null == dates
          ? _value._dates
          : dates // ignore: cast_nullable_to_non_nullable
              as List<DateTime?>,
    ));
  }
}

/// @nodoc

class _$CalendarBuildableImpl implements _CalendarBuildable {
  const _$CalendarBuildableImpl(
      {this.loading = false,
      this.success = false,
      this.failure = false,
      this.selectedDate = "",
      this.dateCount = "",
      this.range = "",
      this.rangeCount = "",
      this.startDate,
      this.endDate,
      this.focusDate,
      final List<DateTime?> dates = const []})
      : _dates = dates;

  @override
  @JsonKey()
  final bool loading;
  @override
  @JsonKey()
  final bool success;
  @override
  @JsonKey()
  final bool failure;
  @override
  @JsonKey()
  final String selectedDate;
  @override
  @JsonKey()
  final String dateCount;
  @override
  @JsonKey()
  final String range;
  @override
  @JsonKey()
  final String rangeCount;
  @override
  final DateTime? startDate;
  @override
  final DateTime? endDate;
  @override
  final DateTime? focusDate;
  final List<DateTime?> _dates;
  @override
  @JsonKey()
  List<DateTime?> get dates {
    if (_dates is EqualUnmodifiableListView) return _dates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dates);
  }

  @override
  String toString() {
    return 'CalendarBuildable(loading: $loading, success: $success, failure: $failure, selectedDate: $selectedDate, dateCount: $dateCount, range: $range, rangeCount: $rangeCount, startDate: $startDate, endDate: $endDate, focusDate: $focusDate, dates: $dates)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CalendarBuildableImpl &&
            (identical(other.loading, loading) || other.loading == loading) &&
            (identical(other.success, success) || other.success == success) &&
            (identical(other.failure, failure) || other.failure == failure) &&
            (identical(other.selectedDate, selectedDate) ||
                other.selectedDate == selectedDate) &&
            (identical(other.dateCount, dateCount) ||
                other.dateCount == dateCount) &&
            (identical(other.range, range) || other.range == range) &&
            (identical(other.rangeCount, rangeCount) ||
                other.rangeCount == rangeCount) &&
            (identical(other.startDate, startDate) ||
                other.startDate == startDate) &&
            (identical(other.endDate, endDate) || other.endDate == endDate) &&
            (identical(other.focusDate, focusDate) ||
                other.focusDate == focusDate) &&
            const DeepCollectionEquality().equals(other._dates, _dates));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      loading,
      success,
      failure,
      selectedDate,
      dateCount,
      range,
      rangeCount,
      startDate,
      endDate,
      focusDate,
      const DeepCollectionEquality().hash(_dates));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CalendarBuildableImplCopyWith<_$CalendarBuildableImpl> get copyWith =>
      __$$CalendarBuildableImplCopyWithImpl<_$CalendarBuildableImpl>(
          this, _$identity);
}

abstract class _CalendarBuildable implements CalendarBuildable {
  const factory _CalendarBuildable(
      {final bool loading,
      final bool success,
      final bool failure,
      final String selectedDate,
      final String dateCount,
      final String range,
      final String rangeCount,
      final DateTime? startDate,
      final DateTime? endDate,
      final DateTime? focusDate,
      final List<DateTime?> dates}) = _$CalendarBuildableImpl;

  @override
  bool get loading;
  @override
  bool get success;
  @override
  bool get failure;
  @override
  String get selectedDate;
  @override
  String get dateCount;
  @override
  String get range;
  @override
  String get rangeCount;
  @override
  DateTime? get startDate;
  @override
  DateTime? get endDate;
  @override
  DateTime? get focusDate;
  @override
  List<DateTime?> get dates;
  @override
  @JsonKey(ignore: true)
  _$$CalendarBuildableImplCopyWith<_$CalendarBuildableImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
